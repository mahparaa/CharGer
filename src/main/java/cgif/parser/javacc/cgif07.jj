/**
    This is the token and grammar file for defining CGIF's syntax and constructing an appropriate
    CG graph from it.
    Uses javacc as its engine.
*/

options {
    STATIC = false;
    SANITY_CHECK = true;
    DEBUG_PARSER = true;
}

PARSER_BEGIN(CGIFParser)
package cgif.parser.javacc;

import cgif.generate.NameGenerator;
import cgif.parser.CGIFSubtypeException;
import cgif.parser.CGIFVariableException;
import java.io.ByteArrayInputStream;
import java.io.InputStream;
import cgif.parser.CGIFParserHelper;
import charger.Global;
import charger.obj.Actor;
import charger.obj.Graph;
import charger.obj.Concept;
import charger.obj.Relation;
import charger.obj.Referent;
import charger.obj.TypeLabel;
import java.io.Reader;
import java.util.ArrayList;

public class CGIFParser {
    private CGIFParserHelper helper = new CGIFParserHelper();
    private Graph topGraph = new Graph();

    public  Graph parseCGIFString( String contents ) throws ParseException {
        InputStream is = new ByteArrayInputStream(contents.getBytes());
        ReInit( is );
        topLevelGraph( );
        return topGraph;
    }

    public void reset() {
        this.ReInit( (Reader) null );
        topGraph.dispose();
        topGraph = new Graph();
        helper.referents.clear();
    }

    public Graph getGraph() {
        return topGraph;
    }
}

PARSER_END(CGIFParser)

SKIP : { " " | "\t" | "\n" | "\r" }

MORE : { "/*" : IN_MULTI_LINE_COMMENT }
<IN_MULTI_LINE_COMMENT> SPECIAL_TOKEN : { <MULTI_LINE_COMMENT: "*/" > : DEFAULT }
<IN_MULTI_LINE_COMMENT> MORE : { < ~[] > }

TOKEN : {
  <LBRACE: "{"> | <RBRACE: "}"> | <LPAREN: "("> | <RPAREN: ")"> | <LBRACKET: "["> | <RBRACKET: "]"> |
  <COLON: ":"> | <QUESTIONMARK: "?"> | <STAR: "*"> | <COMMA: ","> | <ATSIGN: "@"> | <POUNDSIGN: "#"> |
  <LESSTHAN: "<"> | <GREATERTHAN: ">"> | <BAR: "|"> | <DOUBLEQUOTE: "\"">
}

TOKEN : {
    <TYPE: "Type" | "TYPE"> | <SUBTYPE: "subtype"> | <FORALL: "@every"> | <DIST: "@dist"> | <COLL: "@coll">
}

/* LITERALS */
TOKEN : {
  < INTEGER_LITERAL: <DECIMAL_LITERAL> (["l","L"])? | <HEX_LITERAL> (["l","L"])? | <OCTAL_LITERAL> (["l","L"])? >
| < #DECIMAL_LITERAL: ["1"-"9"] (["0"-"9"])* >
| < #HEX_LITERAL: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+ >
| < #OCTAL_LITERAL: "0" (["0"-"7"])* >
| < FLOATING_POINT_LITERAL: (["0"-"9"])+ "." (["0"-"9"])* (<EXPONENT>)? (["f","F","d","D"])? | "." (["0"-"9"])+ (<EXPONENT>)? (["f","F","d","D"])? | (["0"-"9"])+ <EXPONENT> (["f","F","d","D"])? | (["0"-"9"])+ (<EXPONENT>)? ["f","F","d","D"] >
| < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
| < QUOTED_STRING: "\"" ( "\\" ~[] | ~["\"","\\"] )* "\"" >
| < CHARACTER_LITERAL: "'" ( (~["'","\\","\n","\r"]) | ("\\" ( ["n","t","b","r","f","\\","'","\""] | ["0"-"7"] ( ["0"-"7"] )? | ["0"-"3"] ["0"-"7"] ["0"-"7"] )) ) "'" >
}

/* IDENTIFIERS */
TOKEN : {
  < IDENTIFIER:  <LETTER> (<PART_LETTER>)* >
| < #LETTER: [ "$", "A"-"Z", "_", "a"-"z" ] >
| < #PART_LETTER: [ "\u0000"-"\u0008", "\u000e"-"\u001b", "$", "0"-"9", "A"-"Z", "_", "a"-"z", "-" ] >
}

void topLevelGraph() : {} { graph( null )<EOF> }

Graph graph( Graph enclosingGraph ) : {
    Graph g;
    if ( enclosingGraph == null ) g = topGraph;
    else g = new Graph( enclosingGraph );
} {
  ( cgifTerm( g ) )* { return g; }
}

void cgifTerm( Graph g) : {} { concept( g ) | relation( g ) | actor( g ) }

void concept( Graph g ) :
{
    Token tBracket;
    Token tType = null;
    Referent referent = null;
    Concept concept = null;
    Graph graph = null;
}
{
   LOOKAHEAD(3)
    <LBRACKET> tType = <TYPE> <COLON> referent = referent() tBracket=<RBRACKET>
    {
        if (Global.importSubtypeRelationsAsHierarchy ) {
            try {
                helper.makeTypeLabel( g, referent.getReferentString(), helper.extractChargerComment( tType, tBracket ) );
            } catch ( CGIFSubtypeException ex ) { Global.error( "Error: " + ex.getMessage() ); }
        } else {
            concept = helper.makeConcept( g, "Type", referent, helper.extractChargerComment( tType, tBracket ) );
        }
    }
|  LOOKAHEAD(4)
  <LBRACKET>  tType = typelabel() [<COLON> referent = referent()] tBracket = <RBRACKET >
    {
        // FIX: The helper must link the referent (which contains the *x1 handle) to this concept
        concept = helper.makeConcept( g, tType.image, referent, helper.extractChargerComment( tType, tBracket ) );
    }
|   <LBRACKET> [tType = typelabel()  <COLON> ] graph = graph( g ) tBracket = <RBRACKET >
    {
        if ( tType != null ) graph.setTextLabel( tType.image );
    }
}

Token typelabel() : { Token first = null; }
{
    first = <IDENTIFIER> { return first; }
|   first = <QUOTED_STRING> { return first; }
|   { first = new Token(); first.image = ""; return first; }
}

Referent referent() :
{
    Token t = null;
    Referent ref = null;
}
{
    LOOKAHEAD(2)
    <QUESTIONMARK> t = <IDENTIFIER>
    {
        ref = new Referent();
        ref.setVariable("?" + t.image);
        ref.setReferentString("?" + t.image, false);
        return ref;
    }
|   <STAR> t = <IDENTIFIER>
    {
        ref = new Referent();
        ref.setVariable("*" + t.image);
        // FIX: Ensure the referent string is set to the variable handle for lookup
        ref.setReferentString("*" + t.image, false);
        return ref;
    }
|   t = <IDENTIFIER>
    {
        ref = new Referent(t.image);
        ref.setReferentString(t.image, false);
        return ref;
    }
|   t = <QUOTED_STRING>
    {
        ref = new Referent(t.image);
        ref.setReferentString(t.image, false);
        return ref;
    }
|   ( t = <INTEGER_LITERAL> | t = <FLOATING_POINT_LITERAL> )
    {
        ref = new Referent();
        ref.setReferentString(t.image, false);
        ref.setNumber(Double.parseDouble(t.image));
        return ref;
    }
|   ref = setReferent() { return ref; }
}

void relation( Graph g ) :
{
    Token rname;
    Token rparen;
    Relation relation = null;
    Referent r = null;
    ArrayList<String> variables = new ArrayList<String>();
}
{ LOOKAHEAD(4)
   <LPAREN> rname = <SUBTYPE> <IDENTIFIER> <IDENTIFIER> rparen = <RPAREN>
   { /* Subtype logic omitted for brevity, kept as per original */ }
|   <LPAREN> rname = <IDENTIFIER>
    (
        r = referent()
        {
            // FIX: This sends the handle (e.g. *x1) to the helper
            if ( r.getVariable() != null )
                variables.add( r.getVariable() );
            else
                variables.add( r.getReferentString() );
        }
    )+
    rparen = <RPAREN>
    {
        try {
            relation = helper.makeRelation( g, rname.image, variables, helper.extractChargerComment( rname, rparen ) );
        } catch ( CGIFVariableException ex ) { Global.warning( "Error: " + ex.getMessage() ); }
    }
}

void actor( Graph g ) :
{
    Token aname;
    Token rparen;
    Referent r = null;
    ArrayList<String> inputvariables = new ArrayList<String>();
    ArrayList<String> outputvariables = new ArrayList<String>();
}
{
  <LESSTHAN> aname = <IDENTIFIER> ( r = referent() { inputvariables.add( r.getVariable() ); } )+
  <BAR> ( r = referent() { outputvariables.add( r.getVariable() ); } )+
  rparen = <GREATERTHAN>
    {
        try {
            helper.makeActor( g, aname.image, inputvariables, outputvariables, helper.extractChargerComment( aname, rparen ) );
        } catch ( Exception ex ) { Global.warning( "Error: " + ex.getMessage() ); }
    }
}

String variable() : { String prefix = null; Token var = null; }
{
    prefix = prefix() var = <IDENTIFIER> { return (prefix == null ? "" : prefix) + var.image; }
}

String prefix() : { Token pre = null; }
{
    pre = <QUESTIONMARK> { return pre.image; } | pre = <STAR> { return pre.image; }
}

Referent setReferent() : { Referent ref = new Referent(); Referent r; String card = null; }
{
    <LBRACE> r = referent() { ref.addSetMember( r ); } ( <COMMA> r = referent() { ref.addSetMember( r ); } )* <RBRACE> [ card = cardinality() ]
    { if ( card != null ) ref.setCardinality( card ); return ref; }
}

String cardinality() : { Token d = null; }
{
    <ATSIGN> d = <INTEGER_LITERAL> { return d.image; }
}